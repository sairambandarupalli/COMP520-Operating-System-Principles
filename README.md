# COMP520-Operating-System-Principles

# Explanation of ProjectA (The below description is only about kernel.c and it's essential to acknowledge that the given description doesnot include the entire code and might make reference to supplementary functions that are not explicitly outlined.)
The code initializes variables for video memory and a string. It uses a loop to write each character and a white color attribute to consecutive video memory locations. The program then enters an infinite loop, keeping the message on the screen. However, the putInMemory function, responsible for writing to memory, is not provided in the snippet.

To verify the code, run the commands in terminal chmod + x compileOS.sh and ./compileOS.sh. If the code runs successfully, then run java -jar simulator.jar

# Explanation of ProjectB (The below description is only about kernel.c and it's essential to acknowledge that the given description doesnot include the entire code and might make reference to supplementary functions that are not explicitly outlined.)
The main function takes a sector from the disc, reads user input, and sets up interrupt handling. Using BIOS video interrupts, the printString and printChar functions output characters and strings to the screen. The function readString receives input from the user and manages backspace for editing. The handleInterrupt21 function uses BIOS interrupts to carry out various activities, routing them according to the value of the 'ax' register. 

To verify the code, run the commands in terminal chmod + x compileOS.sh and ./compileOS.sh. If the code runs successfully, then run java -jar simulator.jar

# Explanation of ProjectC (The below description is only about kernel.c and shell.c, it's essential to acknowledge that the given description doesnot include the entire code and might make reference to supplementary functions that are not explicitly outlined.)
The kernel is responsible for initializing an interrupt vector table and performing various tasks. One of these tasks involves reading the contents of a file named "message" into a buffer and displaying the content. If the file is not found, the kernel starts a simple shell. This shell provides functions for file system operations, I/O tasks (such as printing strings and characters), and program execution. When the kernel needs to terminate, it executes a program called "shell" to return to the command prompt.

The shell, defined in shell.c, operates in a continuous loop, accepting user input and interpreting commands. It supports commands like "type" to display file contents and "exec" to run programs. If a command is not recognized, the shell handles it by printing appropriate messages. The provided code focuses on interacting with hardware through interrupt calls. The file system and shell components offer essential features for a basic operating system environment, and it is important to note that additional functions, not included in the provided snippet, are relied upon.

To verify the code, run the commands in terminal chmod + x compileOS.sh and ./compileOS.sh. If the code runs successfully, then run java -jar simulator.jar

# Explanation of ProjectD (The below description is only about kernel.c and shell.c, it's essential to acknowledge that the given description doesnot include the entire code and might make reference to supplementary functions that are not explicitly outlined.
kernel.c is the central component of an operating system kernel that handles low-level operations such as printing characters, reading strings, and performing operations at the sector level for file manipulation. It establishes a basic shell by utilizing the makeInterrupt21 function. The kernel also includes essential functionalities like program execution, interrupt handling, and file system management. The handleInterrupt21 function acts as a system call dispatcher, directing different operations based on the value of the ax register. In summary, the kernel's primary purpose is to facilitate core operations required for a basic operating system.

shell.c is a program that runs within the environment created by the kernel. It provides users with a command-line interface where they can enter commands. The shell continuously waits for user input and uses the isCommand function to identify and interpret the commands entered by the user. The supported commands include "type" for displaying file contents, "exec" for executing programs, "dir" for listing directory contents, "del" for deleting files, "copy" for copying files, and "create" for creating files. The shell utilizes system calls to communicate with the underlying kernel, enabling users to interact with the file system and perform various operations. Overall, shell.c offers a user-friendly interface for interacting with the basic operating system.

To verify the code, run the commands in terminal chmod + x compileOS.sh and ./compileOS.sh. If the code runs successfully, then run java -jar simulator.jar

# Explanation of ProjectE (The below description is only about kernel.c and shell.c, it's essential to acknowledge that the given description doesnot include the entire code and might make reference to supplementary functions that are not explicitly outlined.)
The kernel, implemented in the kernel.c file, is responsible for coordinating essential operating system functions. It includes a process management system that can create, terminate, and wait for processes. The kernel keeps track of active processes, their stack pointers, and processes waiting for others. It also handles interrupts, such as a custom interrupt 21h for system calls and a timer interrupt (int 0x08) for time-sharing among processes. File-related operations like reading and writing sectors, reading files, executing programs, terminating processes, deleting files, and managing process states are supported by the kernel. The timer interrupt includes a process scheduler that allocates processor time to active processes, updates their stack pointers, and ensures smooth execution.

The shell, implemented in the shell.c file, acts as the user interface for interacting with the kernel. It provides a set of commands, including "type" for displaying file contents, "exec" and "execb" for executing programs, "dir" for listing files, "del" for deleting files, "copy" for copying files, "create" for creating new files, and "kill" for terminating specific processes. The shell continuously waits for user input, interprets commands, and invokes corresponding kernel functions to perform file operations or manage processes. Together, this system offers a simplified but functional operating environment with the capability to handle basic file operations and process management through a command-line interface.

To verify the code, run the commands in terminal chmod + x compileOS.sh and ./compileOS.sh. If the code runs successfully, then run java -jar simulator.jar

